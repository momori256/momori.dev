<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | Momori Nakano</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Momori Nakano">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.364d6b9256fe5f2d0b7be3f86155a0ceaa731e7ce41aaee3cb04a613cd629a45.css" integrity="sha256-Nk1rklb&#43;Xy0Le&#43;P4YVWgzqpzHnzkGq7jywSmE81imkU=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class="list dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Momori Nakano (Alt + H)">Momori Nakano</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">『論理学をつくる』で論理学をつくる
    </h2>
  </header>
  <div class="entry-content">
    <p>導入 記事のタイトルがトートロジーになっています. トートロジーというのは
「トマトはなぜ赤いんだ？」
「赤いから赤いんだよ」
というような, 無意味な同じ言葉の繰り返しのことです.
ところで, 論理学では常に真になる文のことをトートロジーと言います. 例えば「クジラは哺乳類であるか, 哺乳類でないかのどちらかだ」というような文は, クジラについて何もわかっていかなったとしても正しいとわかるトートロジーです.
では以下の文はどうでしょう.
この占い師が信用できるなら, 私の明日旧友と出会う この占い師は信用できる よって, 私の明日旧友と出会う 理屈は正しそうです. ではこれはどうでしょう.
この占い師が信用できるなら, 私の明日旧友と出会う 私は翌日旧友と出会った よって, この占い師は信用できる 予言が当たったのなら本物感はありますが, インチキ占い師が適当なことを言ったのにも関わらず, たまたま予言が当たったという可能性もありそうです. ということでこの理屈は間違っていると言えそうです.
常に正しい文, 論理的に正しい/間違った推論. こういった事柄を厳密に扱うのが論理学です.
なんだ, 論理学は随分当たり前のことを研究するんだなぁと思うかもしれません. しかし, 推論の正しさや矛盾と言った事柄を一般的に, 明確に, 統一的に示すのは難しそうです. 普段行っている論理的判断であっても, それがなぜ正しいのか説明できなかったり, 対象が複雑になると判断がつかなくなったりします.
本書は論理学を全く学んだことのない人のための教科書です.
初学者でも独学できるように丁寧な説明や練習問題が満載です (ちゃんと練習問題に解説がついているのは嬉しいポイントです. というかなぜ大学の教科書のような本にはついてないことが多いのでしょう). 身近な例から始まって, 述語論理, 自然演繹, 非古典論理など, 様々な話題が盛り込まれています.
序文によると, このような欲張りな目標を立てたために本が分厚くなった (B5 版 400 ページ以上) という事情のようです.
論理学というといかにも堅苦しそうな分野ですが, 著者の軽妙な語り口も相まって気負わず読み進められます. 論理学には全く触れたことはないが, きちんと入門してみたいという方におすすめです.
印象に残った点 タイトル通り, 論理というものを厳密に扱うための体系を少しずつ作っていくのが本書のスタイルです. 記号と抽象の奥深い世界が広がっています. 印象的な部分をまとめます.
論理学を「つくる」とはどういうこと？ 論理を研究するに当たって最初に行う作業は, 論理を厳密に扱うことができる体系を作ることです. つまり, 論理を扱うのに都合の良い言語を作って, その人口言語を操作することで話が進みます....</p>
  </div>
  <footer class="entry-footer"><span title='2021-10-24 00:00:00 +0000 UTC'>October 24, 2021</span>&nbsp;·&nbsp;11 min</footer>
  <a class="entry-link" aria-label="post link to 『論理学をつくる』で論理学をつくる" href="http://localhost:1313/posts/build-logic/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">『例解 UNIX/Linux プログラミング教室』でシステムプログラミングを学ぶ
    </h2>
  </header>
  <div class="entry-content">
    <p>概要 UNIX/Linux の機能を使ったシステムプログラミングを解説する本です (出版社のサイト). 副題は「システムコールを使いこなすための 12 講」であり, システムコールに焦点を当てて 幅広く UNIX の概念について解説するスタイルです. ちなみに, タイトルに UNIX と Linux の 2 つの名前がありますが本書の内容はどちらにも通用するものです. この記事でも UNIX/Linux 両方について言及する時は省略して UNIX とだけ書きます.
0-4 章はよく使うコマンドなどの UNIX の基礎や C 言語の復習, ファイル入出力などの基本的な内容で, 5 章以降から本題に入る流れです. 5 章以降で扱われるトピックは, プロセス, ファイルシステム, ソケット, シグナル, 端末などです.
UNIX のシステムプログラミングをしたい方や, UNIX 内部の仕組みを知りたいという方におすすめです.
印象に残ったこと 調べ方を知る 本書は割と分厚い本 (約 500 ページ) ですが辞書ではありません. 大量のシステムコールや UNIX の細かい挙動について網羅的に覚えるのではなく, 必要なときに必要なものを調べられるように概念や機能を学ぶというアプローチです. このアプローチのおかげか, 序盤に man コマンドの使い方が紹介されています. man コマンド自体はすでに知っていたのですが, 長くて分かりにくいメッセージが表示されるものという印象があってほとんど使ったことはありませんでした. しかし, どこに注目すればよいかが分かれば便利なものだと気付きました. 例えば, 今まではシステムコールやライブラリを使うのに include が必要なヘッダファイルを毎回ネットで検索していたのですが, man で見たほうが早いし正確です (環境によって微妙に必要なヘッダが違うことがあるらしいので)....</p>
  </div>
  <footer class="entry-footer"><span title='2021-09-12 00:00:00 +0000 UTC'>September 12, 2021</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to 『例解 UNIX/Linux プログラミング教室』でシステムプログラミングを学ぶ" href="http://localhost:1313/posts/linux-system-programming/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">『プログラミング in OCaml』で関数型言語に入門
    </h2>
  </header>
  <div class="entry-content">
    <p>感想 関数型言語を学ぶため, 『プログラミング in OCaml』を読みました (出版社のページ). 関数型言語や関数型プログラミングといった言葉を何度か耳にして気になっていたので入門してみることにしました. OCaml という (マイナー?) な言語を選んだのにはそれほどの理由はありません. C&#43;&#43; を知っていれば Java や C# など他のオブジェクト指向言語もおおよそ似たようなものに感じられるように, 関数型言語を 1 つ学べば他の理解もスムーズになるだろうと思ったという程度です.
関数型言語ならではの考え方に触れたり,他言語に輸入されたであろう機能を見たりして楽しめました. 後半で詳しく書いていますが, 木のようなデータ構造を型で表現できる機能や再帰を使ったエレガントな書き方には感動しました. 基礎から説明してあるので, 関数型言語を学んだことのない方にもおすすめの本です.
印象に残ったこと いくつかピックアップして印象的な点を振り返ります.
OCaml の歴史 ML というプラグラミング言語の処理系の 1 つらしいのですが, 祖先に当たる ML は元々コンピュータで数学の手切りを証明するためのシステムに起源を持つ言語のようです. この説明だけでも, ML やその派生言語が C 言語系 (ALGOL 系?) の言語と出自が異なるということが感じられます. 関数型言語では「プログラムを実行する = 関数を実行してその解を得る」という捉え方です. プログラムは複数の関数の組み合わせであり, その関数を実行していくことがプログラムの目的ということです. これが関数型と言われる所以だと思います.
強力な型推論 型推論自体は多くのメジャーな静的型付け言語に備わっている機能だと思います. 本書では, OCaml は基本的に必要がなければ型は書かなくて良いというスタンスで, これは型推論が言語の中心的な機能として最初から考えられていたからこそのものだと思いました. 例えば C&#43;&#43; にも 型推論の auto はあります. これは C&#43;&#43;11 から追加された機能で, 便利ですが乱用するのは良しとされない印象があります. あまりにも長い型名 (iterator など) や冗長な型宣言を省略するというあくまでも補助的な機能のように感じます....</p>
  </div>
  <footer class="entry-footer"><span title='2021-08-22 00:00:00 +0000 UTC'>August 22, 2021</span>&nbsp;·&nbsp;6 min</footer>
  <a class="entry-link" aria-label="post link to 『プログラミング in OCaml』で関数型言語に入門" href="http://localhost:1313/posts/programming-in-ocaml/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">『Effective C&#43;&#43;』は中級者への足がかりとなる濃密なガイドライン
    </h2>
  </header>
  <div class="entry-content">
    <p>より良い C&#43;&#43; コードを書くためのガイドラインとなる『Effective C&#43;&#43;』第 3 版を読みました. (出版社のページ). 有用な知識やアドバイスが多く非常に良い勉強になりました. 学んだことや感想を記します.
感想 C&#43;&#43; の本として有名な本書の名前は聞いたことがあり昔軽く手にとってみたことがあったのですが, いまいちピンとこず, 大事なことが書いてあるのだろうけどよくわからない難しい本という印象をもっていました. しかし改めて読んでみると, C&#43;&#43; の経験をある程度積んだおかげか, 非常に有用で興味深い内容に感じられました. すでに知っていることが 3 割, 知らなかった or よく理解していなかったことが 7 割程度でした.
今までこんなにも多くのことを知らずに C&#43;&#43; を使っていたのかと愕然としたり, こんなに細かいことまで気にしなければならないのかと 引いたり 驚いたりしました.
印象に残ったこと 印象に残った項目をいくつかピックアップして振り返ります.
7 項, 36 項 ポリモーフィズムのための基底クラスには仮想デストラクタを宣言する 非仮想関数を派生クラスで再定義するのは NG まず本書序盤の 7 項で「ポリモーフィズムのための基底クラスには仮想デストラクタを宣言しよう」というタイトルが付けられているのですが, 最初はタイトルを見ても何のことだかさっぱり分かりませんでした. 基底クラスのデストラクタを仮想にしておかないとメモリが正常に開放されないことがあるという内容で, へぇーと思ったのですが, ちゃんと理解できたのは後半の 36 項を読んでからでした. 36 項では, 非仮想関数を派生クラスで再定義すると, 呼び出し方によって基底/派生クラスのどちらの関数が呼ばれるか変わってしまうということが説明されています. これを読んでようやく 7 項の意味が分かりました. 派生クラスは必ずデストラクタを再定義するので, 基底クラスのデストラクタは仮想にしなければならないということです. この項だけでも継承, 仮想関数, コンパイラによるコンストラクタ/デストラクタの自動生成といったことへの知識が必要になり, 自分の知識のなさや理解の浅さを実感しました. そして, もしこれを知らないままポリモーフィズムを使っていた場合, 原因不明のメモリ異常に悩まされることになっていただろうと思うと恐ろしくもありました. C&#43;&#43; の奥深さに気付かされた印象的な項目でした.
13 項 リソース管理にはオブジェクトを使う オブジェクトがスコープを抜けるときデストラクタが自動実行されることを利用してリソースの解法忘れを防ぐという内容です....</p>
  </div>
  <footer class="entry-footer"><span title='2021-08-21 00:00:00 +0000 UTC'>August 21, 2021</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to 『Effective C&#43;&#43;』は中級者への足がかりとなる濃密なガイドライン" href="http://localhost:1313/posts/effective-cpp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">『コンピュータシステムの理論と実装』でハードとソフトをまたいでコンピュータを理解する
    </h2>
  </header>
  <div class="entry-content">
    <p>コンピュータを 0 から自分の手で作り上げるという意欲的な内容です. 論理ゲートから始まって高水準言語を実装し,その言語で OS を作成するという過程は旅という言葉がしっくりくるほど濃密なものでした.
内容 コンピュータの構築を通じてコンピュータ・サイエンスにおける重要なテーマを学びます ( 出版社のサイト ).
ハードウェア (論理演算, CPU, メモリ) ハードとソフト全体が協調するシステムのアーキテクチャ プログラミング言語 (コンパイラ, オブジェクト指向) OS (メモリ管理, 数学/幾何アルゴリズム, I/O など) ソフトウェアエンジニアリング (モジュール化, テスト, API デザインなど) ハードウェア → ソフトウェアとボトムアップにコンピュータ構築を進めていきます. ハードウェア編では論理ゲートから始まって CPU とメモリを実装し, 最終的にノイマン型アーキテクチャのコンピュータを作り上げます. ソフトウェア編ではアセンブラ, バーチャルマシン, コンパイラと進んで高級言語を実装する過程がメインです. 最後に実装した高級言語で OS を作成します.
自分の手で作るということが本書のテーマであり, 各章には説明と仕様だけがあり答えはありません. ハードウェアの設計にはハードウェア記述言語 (HDL) を用い, シミュレータで実行するので実際に電子部品を組み立てる必要はありません. ソフトウェア編で作成するコンパイラは自分の好みの言語で実装します.
感想 ハードウェアの設計は初体験だったのですが, パズルを解くような感覚で楽しめました. 多少苦労した箇所もありましたが, ハードウェア編でかかった時間は各章 2 時間程度でした.
それよりも遥かに苦戦したのはコンパイラの実装です. 今でこそ各章の内容が秩序立って理解できますが, 当初はそもそも何をすれば良いのかわからず, 何度も説明を読んだり試しに実装をしたりしてなんとか進めてきました. ソフトウェア編全体でかかった時間は 100 時間近いと思います. 本書に取り組んでいて迷ったときのコツですが, アセンブラとコンパイラは完成品が提供されているのでその挙動を見ると良いと思います. 私は最初コンパイラが何をすればよいのかさっぱりつかめなかったのですが, 提供されているコンパイラを実行して理解できました.
大変な苦労はしましたが, 全体を通じて有意義な学びが多く取り組んで良かったと思っています. コンピュータの仕組みを実際に作りながら学びたいという方には非常におすすめです....</p>
  </div>
  <footer class="entry-footer"><span title='2021-07-18 00:00:00 +0000 UTC'>July 18, 2021</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to 『コンピュータシステムの理論と実装』でハードとソフトをまたいでコンピュータを理解する" href="http://localhost:1313/posts/nand2tetris/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/posts/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Momori Nakano</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
